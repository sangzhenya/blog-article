---
title: "敏捷开发的六个原则"
tags: ["读书笔记", "设计模式"]
categories: ["读书笔记"]
date: "2019-01-11T09:00:00+08:00"
---

1. 单一职责原则（SRP）

   一个类只做一件事。就一个类而言，应该仅有一个引起它变化的原因。职责就是变化的原因，如果你多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。

2. 开放 - 闭合原则（OCP）

   软件实体（类，模块，函数等等）应该可以扩展的，但是不可修改的。如果程序的一处改动就会产生连锁反应，导致一系列相关模块的改动，那么设计就具有僵化性的臭味。建议对系统进行重构，这样以后的改动，就不会导致更多的修改。如果正确的使用OCP，那么以后再进行同样的改动，就只需要添加新的代码，而不必改动已经正常运行的代码。

   开放 - 封闭原则的两个特征：对于扩展是开放的；对于更改是封闭的。这两点特征看起来是矛盾的，关键是要抽象。

   在OOPL中，可以创建出固定却能够描述一组任意可能行为的抽象。这个抽象就是抽象基类。而一组任意个可能的行为表现为可能的派生类。模块可以操作一个抽象体，由于模块依赖一个抽象体，所以对它的修改是关闭的。同时从这个抽象体派生，也可以扩展模块的行为。

   不过事实上，无论模块多么的封闭，都会存在一些无法对之封闭的变化。所以就必须有策略的对待这个问题，也就是说，设计人员必须对于他设计的模块对哪种变化封闭做出选择，必须先猜测出最可能发生变化的种类，然后构造抽象来隔离那些变化。

   对于应用程序的每一个部分都肆意的进行抽象并不是一个好主意。正确的做法是对程序中呈现频繁变化的那些部分做出抽象。拒绝不成熟 的抽象和抽象本身一样重要。

3. Liskov 替换原则 （LSP）

   子类对象必须能够替换掉它们的基本类型。

   提取公共部分是一个设计工具，最好在代码不是很多时应用。如果一组类都支持一个公共的职责，那么它们应该从一个公共的超类继承该职责，如果公共的超类还不存在，那么就创建一个，并把公共的职责放入其中。

4. 依赖倒置原则（DIP）

   高层的模块不应该依赖低层的模块，二者都应该依赖抽象。抽象不应该依赖细节，细节应该依赖于抽象。

   依赖导致并不是仅仅指的的依赖关系的倒置，它也是接口所有权的倒置。我们通常认为工具库应该拥有它们的接口。但是当应用了DIP时，往往应该是客户拥有抽象接口，而它们的服务者则从这些抽象接口派生。低层模块中声明被高层模块调用的接口。 【熔炉示例】

5. 接口隔离原则（ISP）

   如果类的接口不是内聚的，就表示该类具有胖的接口。换句话说，类的胖的接口可以分解成多组方法，每一组方法都服务于一组不同的客户程序。这样一些客户可以使用一组成员函数，而其他客户程序可以使用其它组成员函数。

   一个接口添加一个方法只是为了能给它的一个子类带来好处的，这样这个接口被一个它不需要的方法污染了。如果每次子类需要一个新的方法，这个方法都添加到基类中，那么这个接口就慢慢的变成了一个胖接口了。

   不应该强迫客户依赖它们不使用的方法。需要避免这种耦合，分离接口。如果一个对象的不足必须通过该对象的接口去访问它，也可以通过委托或者该对象的基类去访问它。 【定时门的例子】

   对客户进行分组，这样可以为每组而不是每个客户创建分离的接口，可以极大地减少服务需要实现的接口数量。同时也避免让服务依赖于每个客户类型。



参考：[敏捷软件开发 : 原则、模式与实践](https://book.douban.com/subject/1140457/)