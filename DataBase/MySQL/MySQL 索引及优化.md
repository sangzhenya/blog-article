## MySQL 索引及优化

### 索引

索引是帮助 MySQL 高效获取数据的数据结构，即本质上就是一种数据结构。数据库在存储数据之外还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在数据结构上实现高级的查找算法，一种索引方式如下图所示：

![索引](http://img.programya.com/Snipaste_2019-10-13_17-26-48.png)

一般来说索引文件本身也很大，所以并不会全部存储在内存中，往往以索引文件的形式存储在磁盘上。

### 索引分类

#### 数据结构分类：

1. B+ 树索引
2. Hash 索引
3. FullText 索引
4. R-Tree 索引

#### 物理存储分类：

1. 聚集索引
2. 非聚集索引

#### 逻辑分类

1. 单值索引：即一个索引仅包含单个列，一个表中可以有多个单值索引。
2. 唯一索引：索引列的值必须是唯一的，允许有空值。
3. 复合索引：即一个索引包含多个列。

### 索引结构

平常所说的索引都是指的 B 说结构组织的索引。其中聚集索引、次要索引、覆盖索引、前缀索引和唯一索引默认都是使用 B+ 树索引。此外还有哈希索引等。

B+ 树是 B 树的一种变形，非叶子节点只保存索引，不保存实际数据，数据都保存在叶子节点。形式如下图所示：

![B+ 树](http://img.programya.com/Snipaste_2019-10-13_17-40-22.png)

使用 B+ 树的原因主要有以下几点。

首先是 B+ 树的磁盘读写代价更低，B+ 树的内部节点没有指向关键词具体信息的指针，因此其内部节点相对于 B 树更新，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键词也就越多，相对 IO 读写次数就降低了。

其次 B+ 树的查询效率更稳定，由于非终结点并不是指向文件内容节点，而只是叶子节点中关键词字的索引。所以任何关键词查找都会走一条从根节点到叶子节点的路，所有关键词查询的路径长度相同，每一个数据查询效率相当。

最后 B+ 树的数据存储在叶子结点中，分支节点均为索引，方便入库，只需要扫描一遍叶子结点即可，对于 B 树因为其分支节点同样存储着数据，所以要找到具体的数据需要进行一次树的遍历，所以 B+ 树更适合在区间查询的情况。

### 索引的适用场景

#### 优势

提高数据检索效率，降低数据库的 IO 成本。降低数据排序的成本，降低 CPU 的消耗。需要创建索引场景如下：

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段应该创建索引
3. 查询中与其他表关联的字段，外键关系建立索引
4. 查询中排序的字段
5. 查询中统计或者分组字段

#### 劣势

索引会占据空间的。每次添加或更新索引列的字段，都要更新索引，会降低更新锁的表速度，对大数据量的表需要花时间研究最优索引。不需要创建索引的场景如下：

1. 频繁更新的字段不适合创建索引
2. where 条件中用不到的字段
3. 表记录太少
4. 经常增删改的表
5. 数据重复且分布平均的表字段，因此应该只是为最经常查询和最经常排序的数据列建立索引

### 基本使用

```mysql
-- 创建
create [unique] index index_name on table_name(column_name(length));
alter table_name add [unique] index index_name on (column_name(length));

-- 删除
drop index index_name on table_name;

-- 查看
show index from table_name;
```

### 常见瓶颈

一般发生在数据装入内存或从磁盘上读取数据的时候可能会出现 CPU 饱和，而 磁盘 IO 瓶颈发生在装入数据远大于内存容量的时候。

### Explain 分析

使用 Explain 可以模拟优化器执行 SQL 查询语句，从而知道MySQL 是如何处理 SQL 的，进而分析查询语句或者表结构的性能瓶颈。主要可以查询表的读取顺序，数据读取操作的操作类型，哪些索引可以被使用，哪些索引实际被使用，表之间的引用，每张表有多少行被优化器查询等。主要包含以下内容：

![Explain 查询内容](http://img.programya.com/Snipaste_2019-10-14_22-16-36.png)

#### id

##### id 相同

执行顺序由上至下

```mysql
explain select ce.id, ac.id from category ce where ce.id in (select ac.category_id from article ac);
```

![Explain ID 1](http://img.programya.com/Snipaste_2019-10-14_22-58-45.png)

##### id 不同

如果是子查询，id 的序号递增，值越大优先级越高，越先被执行

```mysql
explain select ac.title from article ac where ac.category_id = (select ce.id from category ce where ce.id = 61);
```

![id 不同](http://img.programya.com/Snipaste_2019-10-14_23-07-13.png)

##### id 不同和相同同时存在

id 如果相同则可以认为是一组，从上往下执行；在所有组中，id 值越大，优先级越高，越先被执行。

#### select_type

主要有 6 种

1. SIMPLE：简单的 select 查询，查询是不包含子查询和 union
2. PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为 PRIMARY
3. SUBQUERY：在 SELECT 或 WHERE 列表中包含了 子查询
4. DERIVED：在 From 列表中包含的子查询被标记为 DERIVED ，MySQL 中递归执行这些子查询，把结果放到临时表中
5. UNION：若第二个 SELECT 出现在 UNION 之后则被标记为 UNION，若 UION 包含在 FROM 查询语句的子查询中，外层 SELECT 被标记为 DERIVED
6. UNION RESULT 从 UNION 表获取的 SELECT

#### table

关于哪张表的信息

#### partitions

如果查询是基于分区表的话，会显示查询将访问的分区。

#### type

访问类型，从好到坏依次如下：

1. system：表只有一行数据，等于系统表，是 const 的特例。
2. const：表示通过索引依次就找到了，用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快将主键置于 where 表中，mysql 就能将该查询转换为一个常量。
3. eq_ref：唯一性索引扫描，每个索引建在表中只有一条与之匹配的记录。常见于固件或唯一索引扫描。
4. ref：非唯一性索引扫描，返回匹配每个单独值的所有行，也是一种索引访问，因为是所以匹配值的行，所以属于查找和扫描的混合体。
5. range：值检索给定范围的行，使用一个所以来算则行。key 列显示使用了哪个索引，通常是在where语句 的between, >, < in 等查询是出现，这种范围扫描索引比全表扫描好一些，因为它只需要开始于索引的某一点，结束于另一点而不用全表扫描。
6. index：Full Index Scan , index 与 All 的区别就是 index 类型只遍历树，这通常比 all 快，因为索引文件通常比数据文件小。
7. all：Full Table Scan 遍历全表找到匹配的行。

一般来讲查询要到 range 级别，最好可以达到 ref。

#### possible_keys

显示可能应用在这个表中的索引，一个或者多个，查询设计到的字段上若有索引，就会显示出来，但不一定真的被查询用到。

#### key

实际使用的索引，如果是 NULL 则表明没有使用到索引，如果是覆盖索引那么则索引和查询的 select 字段是重叠的。

#### key_len

表示索引中使用的字节数，课通过计算查询中的索引的长度，在不损失精确性的情况下，长度越短越好。该列显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表等昆虫计算而来，而不是通过表内检索出来的。

#### ref

显示索引的哪一列被使用了，一般是整数，哪些列或常量被用于查询索引上的值。

#### rows

根据表统计信息及索引使用情况，大致估算出找到需要读取的行数。

#### filtered

 用百分比表示有多少行会被过滤出来去与之前的表关联  rows * filtered / 100 就能得到行数。

#### Extra

其他重要从信息，主要可能出现以下几种类型：

1. Using filesort： 说明 MySQL 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为 “文件排序”。
2. Using temporary： 使用了临时表保存中间结果， MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。
3. Using index：表示相应的 色乐天 操作中使用了 覆盖索引，避免访问了表的数据行。如果同时出现 using where 表明索引被用来执行索引键值的查找；如果没有同时出现 using where 则表明索引用来读取数据而非执行查找动作。
4. Using where：使用了 where 过滤。
5. Using join buffer：使用了连接缓存
6. impossible where： where 字句的值总是 false，不能用来获取任何元祖。
7. select tables optimized way：在没有 groupby 字句的情况下，基于索引优化的 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*) 操作，不必等到执行阶段在进行计算，查询执行计划生成的阶段即完成优化。
8. distinct：优化 distinct 操作，在找到第一匹配的元组后即停止找同样值的动作。

### 索引优化

1. 全值匹配，例如组合索引是 col1 col2 col3, 搜索的时候 where 子句后也应该按照建索引的时候顺序查询。查询从索引的左前列开始并且不要跳过索引中的列。
2. 不要在索引列上做任何操作，包含计算、函数、自动/手动（数字与字符串）类型转换，操作会导致索引失效而转向全表扫描。
3. 存储引擎不能使用索引中范围条件右边的列。例如组合索引是 col1, col2, col3。where 索引后 col1=? and col2 > ? and col3 则 col3 这个索引无法使用。
4. 尽量使用覆盖索引，仅查询索引的列，避免使用 select *。
5. MySQL 中使用不等于（!=, <>），is null, is not null, like '%col'，字符串为加单引号，使用 or 连接的时候无法使用索引。可以使用覆盖索引解决左like 时无法使用索引的问题。



参考：

1. [为什么MySQL数据库索引选择使用B+树？](https://blog.csdn.net/xlgen157387/article/details/79450295)