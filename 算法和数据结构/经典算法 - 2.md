---
title: "经典算法 - 2"
tags: ["算法"]
categories: ["算法"]
date: "2019-01-13T09:00:00+08:00"
---

## 

[toc]

### 字符串（7）

#### 无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

---

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int[] imap = new int[128];
        int res = 0;
        int lastIndex = 0;
        for (int i = 0; i < s.length(); i++) {
            // 上次出现的位置，记录最后一次出现重复的值的位置
            lastIndex = Math.max(imap[s.charAt(i)], lastIndex);
            // 更新结果
            res = Math.max(i - lastIndex + 1, res);
            // 更新上次出现的位置
            imap[s.charAt(i)] = i + 1;
        }
        return res;
    }
}
```

#### 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1:**

```
输入: ["flower","flow","flight"]
输出: "fl"
```

**示例 2:**

```
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```

**说明:**

所有输入只包含小写字母 `a-z` 。

---

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs.length == 0) {
            return "";
        }
        String prefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            while(strs[i].indexOf(prefix) != 0) {
                prefix = prefix.substring(0, prefix.length() - 1);
                if (prefix.equals("")) {
                    return "";
                }
            }
        }
        return prefix;
    }
}
```

#### 字符串的排列

给定两个字符串 **s1** 和 **s2**，写一个函数来判断 **s2** 是否包含 **s1** 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的子串。

**示例1:**

```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```

 

**示例2:**

```
输入: s1= "ab" s2 = "eidboaoo"
输出: False
```

 

**注意：**

1. 输入的字符串只包含小写字母
2. 两个字符串的长度都在 [1, 10,000] 之间

---

```java
class Solution {
    // 主要思路是使用数组记录 string 中 char 的元素个数是否相等
    public boolean checkInclusion(String s1, String s2) {
        char[] a1 = new char[26];
        // 收集 s1 中的 char 
        for (char c : s1.toCharArray()) {
            a1[c - 'a'] += 1;
        }
        char[] a2 = new char[26];
        int l1 = s1.length();
        // 收集 s2 中的 char 保证仅收集和 s1 长度相等的部分，且同时判断两个数组是否相等
        for (int i = 0; i < s2.length(); i++) {
            if (i - l1 >= 0) {
                a2[s2.charAt(i - l1) - 'a'] -= 1;
            }
            a2[s2.charAt(i) - 'a'] += 1;
            if (Arrays.equals(a1, a2)) {
                return true;
            }
        }
        return false;
    }
}
```

#### 字符串相乘

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**示例 1:**

```
输入: num1 = "2", num2 = "3"
输出: "6"
```

**示例 2:**

```
输入: num1 = "123", num2 = "456"
输出: "56088"
```

**说明：**

1. `num1` 和 `num2` 的长度小于110。
2. `num1` 和 `num2` 只包含数字 `0-9`。
3. `num1` 和 `num2` 均不以零开头，除非是数字 0 本身。
4. **不能使用任何标准库的大数类型（比如 BigInteger）**或**直接将输入转换为整数来处理**。

```java
class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) {
            return "0";
        }
        int l1 = num1.length();
        int l2 = num2.length();
        int[] res = new int[l1 + l2];
        for (int i = l1 - 1; i >= 0; i--) {
            int v1 = num1.charAt(i) - '0';
            for (int j = l2 - 1; j >= 0; j--) {
                int v2 = num2.charAt(j) - '0';
                // 计算当前两数相乘 加上 上一次两数相乘的进位数（当前位的数字）
                int sum = v1 * v2 + res[i + j + 1];
                // 结果取余作为当前位的数字
                res[i + j + 1] = sum % 10;
                // 将进位结果放到下一位上
                res[i + j] += sum / 10;
            }
        }
        
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < res.length; i++) {
            if (i == 0 && res[i] == 0) {
                continue;
            }
            sb.append(res[i]);
        }
        return sb.toString();
    }
}
```

#### 翻转字符串里的单词

给定一个字符串，逐个翻转字符串中的每个单词。

 

**示例 1：**

```
输入: "the sky is blue"
输出: "blue is sky the"
```

**示例 2：**

```
输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
```

**示例 3：**

```
输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
```

 

**说明：**

- 无空格字符构成一个单词。
- 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
- 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

```java
class Solution {
    public String reverseWords(String s) {
        String[] raws = s.split(" ");
        StringBuilder res = new StringBuilder();
        for (int i = raws.length - 1; i >= 0; i--) {
            String ts = raws[i].trim();
            if (!ts.equals("")) {
                if (res.length() != 0) {
                    res.append(" ");
                }
                res.append(ts);
            }
        }
        return res.toString();
    }
}
```

#### 简化路径

以 Unix 风格给出一个文件的**绝对路径**，你需要简化它。或者换句话说，将其转换为规范路径。

在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：[Linux / Unix中的绝对路径 vs 相对路径](https://blog.csdn.net/u011327334/article/details/50355600)

请注意，返回的规范路径必须始终以斜杠 `/` 开头，并且两个目录名之间必须只有一个斜杠 `/`。最后一个目录名（如果存在）**不能**以 `/` 结尾。此外，规范路径必须是表示绝对路径的**最短**字符串。

 

**示例 1：**

```
输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。
```

**示例 2：**

```
输入："/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。
```

**示例 3：**

```
输入："/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```

**示例 4：**

```
输入："/a/./b/../../c/"
输出："/c"
```

**示例 5：**

```
输入："/a/../../b/../c//.//"
输出："/c"
```

**示例 6：**

```
输入："/a//b////c/d//././/.."
输出："/a/b/c"
```

```java
class Solution {
    public String simplifyPath(String path) {
        Stack<String> stack = new Stack<>();
        String[] raws = path.split("/");
        for (String rs : raws) {
            if (rs.equals("..")) {
                if (!stack.isEmpty()) {
                    stack.pop();
                }
            } else if (!rs.equals(".") && !rs.equals("")) {
                stack.push(rs);
            }
        }
        if (stack.isEmpty()) {
            return "/";
        }
        StringBuilder res = new StringBuilder();
        for (int i = 0; i < stack.size(); i++) {
            res.append("/").append(stack.get(i));
        }
        return res.toString();
    }
}
```



#### 复原IP地址

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 `'.' `分隔。

 

**示例:**

```
输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]
```

```java
class Solution {
    public List<String> restoreIpAddresses(String s) {
        List<String> res = new ArrayList<>();
        bcip(res, new StringBuilder(), s, 0);
        return res;
    }
    
    private void bcip(List<String> res, StringBuilder current, String s, int k) {
        // 最长只能有 4 段
        if (k == 4 || s.length() == 0) {
            if (k == 4 && s.length() == 0) {
                res.add(current.toString());
            }
            return;
        }
        for (int i = 0; i <= 2 && i < s.length(); i++) {
            // 不能以 0 开头
            if (i != 0 && s.charAt(0) == '0') {
                continue;
            }
            // 获取当前段，parse 成数字应该小于等于 255
            String part = s.substring(0, i + 1);
            if (Integer.parseInt(part) <= 255) {
                // 如果不是第一个则需要添加 》
                if (current.length() != 0) {
                    part = "." + part;
                }
                // 将当前段添加到候选中
                current.append(part);
                // 递归添加
                bcip(res, current, s.substring(i + 1), k + 1);
                // 删除当前段继续执行
                current.delete(current.length() - part.length(), current.length());
            }
        }
    }
}
```



### 数组与排序（10）

#### 三数之和

给你一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？请你找出所有满足条件且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

 

**示例：**

```
给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        // 去重遍历
        Arrays.sort(nums);
        // 边界值
        if (nums == null || nums.length == 0 || nums[0] > 0|| nums[nums.length - 1] < 0) {
            return result;
        }
        for (int i = 0; i < nums.length - 2; i++) {
            // 去重
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            // 第二和第三个值
            int left = i + 1;
            int right = nums.length - 1;
            while (left < right) {
                // 计算 sum
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    // 获取结果
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    // 去重
                    while(left < right && nums[left] == nums[left + 1]) {
                        left += 1;
                    }
                    // 去重
                    while(left < right && nums[right] == nums[right - 1]) {
                        right -= 1;
                    }
                }
								// 抱住每次都会增加或者减少
                if (sum > 0) {
                    right -= 1;
                } else {
                    left += 1;
                }
            }
        }
        return result;
    }
}
```

#### 岛屿的最大面积

给定一个包含了一些 `0` 和 `1` 的非空二维数组 `grid` 。

一个 **岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在水平或者竖直方向上相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 `0` 。)

 

**示例 1:**

```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```

对于上面这个给定矩阵应返回 `6`。注意答案不应该是 `11` ，因为岛屿只能包含水平或垂直的四个方向的 `1` 。

**示例 2:**

```
[[0,0,0,0,0,0,0,0]]
```

对于上面这个给定的矩阵, 返回 `0`。

 

**注意:** 给定的矩阵`grid` 的长度和宽度都不超过 50。

```java
class Solution {
    private int[][] direction = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    int cols = 0;
    int rows = 0;
    public int maxAreaOfIsland(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        rows = grid.length;
        cols = grid[0].length;
        int maxa = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 1) {
                    maxa = Math.max(maxa, dfsa(grid, i, j));
                }
            }
        }
        return maxa;
    }
    
    private int dfsa(int[][] grid, int row, int col) {
        if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] == 0) {
            return 0;
        }
        grid[row][col] = 0;
        int area = 1;
        for (int[] di : direction) {
            area += dfsa(grid, row + di[0], col + di[1]);
        }
        return area;
    }
}
```

#### 搜索旋转排序数组

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 *O*(log *n*) 级别。

**示例 1:**

```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```

**示例 2:**

```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

```java
class Solution {
    public int search(int[] nums, int target) {
        int lo = 0;
        int hi = nums.length - 1;
        while (lo <= hi) {
            int mid = lo + (hi - lo) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            // 左边连续
            if (nums[lo] <= nums[mid]) {
                // 在 lo 和 mid 中间则设置 hi 为 mid 继续查找
                if (target <= nums[mid] && target >= nums[lo]) {
                    hi = mid - 1;
                } else {    // 不在 lo 和 mid 中间，则设置 lo 为 mid 继续查找
                    lo = mid + 1;
                }
            } else { // 右边连续
                // 在 mid 和 hi 中间则设置 lo 为 mid 继续查找
                if (target >= nums[mid] && target <= nums[hi]) {
                    lo = mid + 1;
                } else {    // 不在 mid 和 hi 中间，则设置 hi 为 mid 继续查找
                    hi = mid - 1;
                }
            }
        }
        return -1;
    }
}
```

#### 最长连续递增序列

给定一个未经排序的整数数组，找到最长且**连续**的的递增序列，并返回该序列的长度。

 

**示例 1:**

```
输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 
```

**示例 2:**

```
输入: [2,2,2,2,2]
输出: 1
解释: 最长连续递增序列是 [2], 长度为1。
```

 

**注意：**数组长度不会超过10000。

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int mcnt = 1;
        int cnt = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > nums[i - 1]) {
                cnt += 1;
                mcnt = Math.max(cnt, mcnt);
            } else {
                cnt = 1;
            }
        }
        return mcnt;
    }
}
```

#### 数组中的第K个最大元素

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例 1:**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**说明:**

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        // 翻转求值
        k = nums.length - k;
        int lo = 0;
        int hi = nums.length - 1;
        while (lo < hi) {
            // 计算轴的位置（即轴左边的均比轴小，轴右边的均比轴大）
            int t = partition(nums, lo, hi);
            if (t == k) {
                break;
            } else if (t > k) {
                hi = t - 1;
            } else {
                lo = t + 1;
            }
        }
        return nums[k];
    }
    
    private int partition(int[] nums, int left, int right) {
        // 最左边的值作为轴
        int p = nums[left];
        // 左/右边初始值 -- 后续计算的时候会前置操作，所以 hi 此处 + 1
        int lo = left;
        int hi = right + 1;
        while (lo < hi) {
            // 左边小于轴则一直移动左边的下标
            while (lo < right && nums[++lo] < p) {};
            // 右边大于轴则一直移动右边的下标
            while (hi > left && nums[--hi] > p) {};
            // 左边大于右边则结束循环
            if (lo >= hi) {
                break;
            }
            // 交换左边大于轴和右边小于轴的元素
            swap(nums, lo, hi);
        }
        // 将轴放到正确的位置，此时轴的位置还是初始的元素，hi 处是小于 轴的一个值
        swap(nums, left, hi);
        // 位置
        return hi;
    }
    
    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

#### 最长连续序列

给定一个未排序的整数数组，找出最长连续序列的长度。

要求算法的时间复杂度为 *O(n)*。

**示例:**

```
输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        // 从某个值出发的最⼤连续数
        Map<Integer, Integer> numCntMap = new HashMap<>();
        // 默认全部设置为 1
        for (int num : nums) {
            numCntMap.put(num, 1);
        }
        // 遍历各个元素，逐个去查找连续的值
        for (int num : nums) {
            numCntMap.put(num, forward(numCntMap, num));
        }
        int res = 0;
        for (int cnt : numCntMap.values()) {
            res = Math.max(res, cnt);
        }
        return res;
    }
    
    private int forward(Map<Integer, Integer> numCntMap, int num) {
        // 如果不包含当前的元素，表明查找结束返回 0
        if (!numCntMap.containsKey(num)) {
            return 0;
        }
        // 如果 cnt ⼤于 1 则说明该点已经查找过了，直接返回 cnt
        int cnt = numCntMap.get(num);
        if (cnt > 1) {
            return cnt;
        }
        // 继续查找下⼀个元素的后续可能有多个值
        cnt += forward(numCntMap, num + 1);
        // 将当前值后续的有多少个连续值的结果放到 map 中
        numCntMap.put(num, cnt);
        return cnt;
    }
}
```

#### 第k个排列

给出集合 `[1,2,3,…,*n*]`，其所有元素共有 *n*! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 *n* = 3 时, 所有排列如下：

1. `"123"`
2. `"132"`
3. `"213"`
4. `"231"`
5. `"312"`
6. `"321"`

给定 *n* 和 *k*，返回第 *k* 个排列。

**说明：**

- 给定 *n* 的范围是 [1, 9]。
- 给定 *k* 的范围是[1,  *n*!]。

**示例 1:**

```
输入: n = 3, k = 3
输出: "213"
```

**示例 2:**

```
输入: n = 4, k = 9
输出: "2314"
```

```java
class Solution {
    // https://www.youtube.com/watch?v=xdvPD1IiyUM
    public String getPermutation(int n, int k) {
        char[] res = new char[n];
        ArrayList<Integer> nums = new ArrayList<>();
        int[] fact = new int[n];
        fact[0] = 1;
        // 构建阶乘数组 fact
        for (int i = 1; i < n; i++) {
            fact[i] = fact[i - 1] * i;
        }
        // 获取所有可用元素
        for (int i = 1; i <= n; i++) {
            nums.add(i);
        }
        // 获取 index 位置
        k -= 1;
        for (int i = 0; i < n; i++) {
            // n - 1 - i 表示确定当前位之后还有几位需要确定
            // fact[n - 1 - i] 剩余几位的排列数
            // k / fact[n - 1 - i] 获取当前对应的下标
            res[i] = Character.forDigit(nums.remove(k / fact[n - 1 - i]), 10);
            // 计算还需要多少位
            k = k % fact[n - 1 - i];
        }
        return new String(res);
    }
}
```

班上有 **N** 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个 **N \* N** 的矩阵 **M**，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生**互为**朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

**示例 1:**

```
输入: 
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出: 2 
说明：已知学生0和学生1互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回2。
```

**示例 2:**

```
输入: 
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出: 1
说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。
```

**注意：**

1. N 在[1,200]的范围内。
2. 对于所有学生，有M[i][i] = 1。
3. 如果有M[i][j] = 1，则有M[j][i] = 1。

```java
class Solution {
    public int findCircleNum(int[][] M) {
        int m = M.length;
        boolean[] visited = new boolean[m];
        int cnt = 0;
        for (int i = 0; i < m; i ++) {
            if (!visited[i]) {
                dfsf(M, i, visited);
                cnt += 1;
            }
        }
        return cnt;
    }
    
    private void dfsf(int[][] ffs, int i, boolean[] visited) {
        visited[i] = true;
        for (int j = 0; j < ffs.length; j++) {
            if (ffs[i][j] == 1 && !visited[j]) {
                dfsf(ffs, j, visited);
            }
        }
    }
}
```

#### 合并区间

给出一个区间的集合，请合并所有重叠的区间。

**示例 1:**

```
输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2:**

```
输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, Comparator.comparingInt(o -> o[0]));
        int length = intervals.length;
        List<int[]> ans = new ArrayList<>();
        for (int i = 0; i < length; i++) {
            int[] sa = new int[2];
            sa[0] = intervals[i][0];
            sa[1] = intervals[i][1];
            while (i + 1 < length && sa[1] >= intervals[i+1][0]) {
                sa[1] = Math.max(sa[1], intervals[i + 1][1]);
                i += 1;
            }
            ans.add(sa);
        }
        return ans.toArray(new int[0][]);
    }
}
```



#### 接雨水

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 **感谢 Marcos** 贡献此图。

**示例:**

```
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

```java
class Solution {
    // https://www.bilibili.com/video/av83646139?from=search&seid=9170732822822571265
    public int trap(int[] height) {
        int n = height.length;
        // 0 - i 最高的值
        int[] lo = new int[n];
        // i - n - 1 的最大值
        int[] hi = new int[n];
        for (int i = 0; i < n; i++) {
            lo[i] = i == 0 ? height[i] : Math.max(height[i], lo[i - 1]);
        }
        for (int i = n - 1; i >= 0; i--) {
            hi[i] = i == (n - 1) ? height[i] : Math.max(height[i], hi[i + 1]);
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            // 取左边最大的和右边最大的二者中最小的一个减去当前的即当前能存储水的量
            ans += Math.min(lo[i], hi[i]) - height[i];
        }
        return ans;
    }
}
```



### 链表或树（9）

### 动态与贪心（6）

### 数据结构（3）

### 扩展练习（3）



