## 缓存

[toc]

### JSR 107

首先 JSR 107 即 JCache API的首个早期草案，在 Java JCache 中定义了 5 个核心内容，即 CachingProvider，CacheMaager，Cache，Entry 和 Expiry。

1. CachingProvider 中定义了创建、配置、获取、管理和控制多个 CacheManager, 一个应用可以在运行期间访问多个 CahingProvider。
2. CacheManger 定义了创建、配置、获取和控制多个唯一命名的 Cache，这些 Cache 存在于 CacheManger 的上下文中。一个 CacheManger 仅被一个 CacheProvider 所拥有。
3. Cache 是一个类似 Map 的数据结构并临时存储以 key 为索引的值，一个 Cache 仅被一个 CacheManger 所拥有。
4. Entry 是一个存在于 Cache 中 key - value 对
5. Expiry 每个存储在 Cache 中的条目有一个定义的有效期，一旦超过这个事件，条目为过期状态。一旦过期，条目将不可访问，更新或者删除，缓存的有效期有 ExpiryPolicy 设置。

结构如下图所示：

![结构图](https://i.loli.net/2020/06/24/1LHzeNhpbtrQoxu.png)

### Spring Cache

Spring Cache 的思想和 JSR 107 类似，同样是多级结构。Spring 也支持透明的去添加缓存，和事务管理有点类似。当然这里 Spring 提供的是抽象层，可以有程序选择抽象具体的实现，使用 Ehcache 或者  Redis 等等，核心的两个接口是：`org.springframework.cache.Cache` 和 `org.springframework.cache.CacheManager` ，同时因为 Spring 提供的是抽象所以不会有对于多线程的处理，对于多线程的处理需要实现层去处理。为了使用缓存，需要确认以下两点：

1. 声明缓存：确定哪些方法需要缓存，以及缓存的策略。
2. 缓存配置：使用什么存储和读取缓存

上面说到缓存是透明的，和事务管理有些类似，所以缓存使用和事务管理一样也是基于注解的。具体的注解如下：

1. `@Cacheable` 标注在某个方法上即表明该方法使用缓存，将方法结果放到缓存中。
2. `@CacheEvict` 删除某条缓存。
3. `@CachePut` 基于方法结果更新缓存注解。
4. `@Caching` 在一个方法上使用多个缓存的时候使用到，对缓存分组。
5. `@CacheConfig` 在类级别设置一些改类方法中公用的缓存配置。

#### @Cacheable

首先看一下 `@Cacheable` 注解：这个注解标注在方法上表明该方法是使用缓存缓存的。添加了之后这个方法的结果会放到缓存中，下次以同样参数调用这个方法的时候会直接从缓存中获取值，而不需要再次执行方法内容。一个简单的配置如下：

```java
@Cacheable("books")
public Book findBook(ISBN isbn) {...}
```

上面的方法指定了一个 cache 的名称，当然也可以指定多个缓存的名称，如果指定了多个那么在任何一个 cache 中存在值的时候即直接返回结果，而不重新执行函数。

```java
@Cacheable({"books", "isbns"})
public Book findBook(ISBN isbn) {...}
```

##### 生成缓存的 key

缓存在 Cache 中是一个个键值对，value 是方法的返回值，那么 key 又是如何确定的呢？Spring 提供了一个 `KeyGenerator` 的抽象，并提供了一个默认的实现 `SimpleKeyGenerator`。默认实现生成 key 的规则：

1. 如果没有参数则返回 SimpleKey.EMPTY
2. 如果只有参数那么就使用该参数作为 key
3. 如果有多个参数在返回一个包含所有参数的 SimpleKey

当然也可以自定义 key 的生成规则，毕竟缓存一个泛型的概念但是方法是千差万别的，不同方法的关注点可能不同，例如下面的一个方法，可能只是关心第一个参数，也可能仅仅关系其中的两个，那么如果使用默认的 key 的生成规则显然在这里不是非常合适。因为默认的规则会将所有的参数拼装后作为 key。

```java
@Cacheable("books")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
```

所以 Spring 提供了 SpEL（Spring Expression Language） 指定关心的参数。

```java
@Cacheable(cacheNames="books", key="#isbn")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@Cacheable(cacheNames="books", key="#isbn.rawNumber")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@Cacheable(cacheNames="books", key="T(someType).hash(#isbn)")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
```

当然如果一个 key 的生成规则非常的特殊，或者这个 key 生成的规则需要被共享，那么可以指定自定义的 keyGenerator， 如下所示：

```java
@Cacheable(cacheNames="books", keyGenerator="myKeyGenerator")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
```

Spring 也提供了一个接口可以动态的确定存储到哪些 cache 中，需要使用到 CacheResolver。需要继承 org.springframework.cache.interceptor.CacheResolver 接口，一个简单的示例如下：

```java
public class CustomCacheResolver implements CacheResolver {

    private final CacheManager cacheManager;

    public CustomCacheResolver(CacheManager cacheManager){
        this.cacheManager = cacheManager;
    }

    @Override
    public Collection<? extends Cache> resolveCaches(CacheOperationInvocationContext<?> context) {
        Collection<Cache> caches = new ArrayList<>();
        if(context.getTarget().getClass() == GatewayRepository.class){
            if(context.getMethod().getName().equals("findByBulkId")){
                caches.add(cacheManager.getCache("gatewayCache"));
            }
        }

        return caches;
    }
}
```

```java
@Configuration
@EnableCaching
public class CacheConfiguration extends CachingConfigurerSupport {

    @Bean
    @Override
    public CacheManager cacheManager() {
         // Desired CacheManager
    }

    @Bean
    @Override
    public CacheResolver cacheResolver() {
        return new CustomCacheResolver(cacheManager());
    }
}
```

```java
@Cacheable(cacheResolver="cacheResolver")
```

默认的存储方式对只有一个 cacheManager ，且没有复杂的分辨需求的应用来说是足够了，但是对于有多个 cacheManager 的应用来说，可以指定使用的 cacheManager。

在多线程环境下，也可以使用同步的方式设置缓存，可以通过 sync 设置是否是使用同步的方式，如果使用了同步的方式，当一个线程在计算缓存的值的时候，其他使用到的线程会阻塞一直到缓存的值更新完毕。

```java
@Cacheable(cacheNames="foos", sync=true) 
public Foo executeExpensiveOperation(String id) {...}
```

有条件的缓存，在一些时候缓存可能并不适用于所有条件，所以 Spring 提供了 Condition 属性，例如可以在 cacheable 中设置在某种条件下缓存才会生效。

```java
@Cacheable(cacheNames="book", condition="#name.length() < 32") 
public Book findBook(String name)
```





