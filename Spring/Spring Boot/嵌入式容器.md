## 嵌入式容器

### 对于嵌入式容器的配置

Spring 的基本的 Server 的配置都可以在 `application.yaml` 中通过 `server` 相关的属性进行配置。

![Server 相关的配置](http://img.sangzhenya.com/Snipaste_2019-12-16_23-11-06.png)

其对应的配置类是 

```java
@ConfigurationProperties(prefix = "server", ignoreUnknownFields = true)
public class ServerProperties {
  private final Tomcat tomcat = new Tomcat();
  
  public static class Tomcat {
		private final Accesslog accesslog = new Accesslog();
		private String protocolHeader;
		private String protocolHeaderHttpsValue = "https";
		private String portHeader = "X-Forwarded-Port";
  }
}
```

其内部类 `Tomcat` 用户配置 `Tomcat` 相关的信息。在 `ServletWebServerFactoryCustomizer` 会使用 其中的配置对 嵌入式容器进行配置， 同样也可以通过使用 `WebServerFactoryCustomizer` 去配置嵌入式容器，例如如下：

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Bean
    public WebServerFactoryCustomizer<ConfigurableWebServerFactory> customizer() {
        return factory -> factory.setPort(8081);
    }
}
```

### 在嵌入式容器中使用 Web 三大组件

#### Servlet

可以使用 `ServletRegistrationBean` 进行注册。

```java
public class MyServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.getWriter().write("Hello World");
    }
}

@Bean
public ServletRegistrationBean<MyServlet> myServlet() {
  ServletRegistrationBean<MyServlet> servletRegistrationBean = new ServletRegistrationBean<>(new MyServlet(), "/servlet");
  servletRegistrationBean.setLoadOnStartup(1);
  return servletRegistrationBean;
}
```



#### Filter

可以使用 `FilterRegistrationBean` 进行注册。

```java
public class MyFilter extends HttpFilter {
    private Log log = LogFactory.getLog(MyFilter.class);
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        log.info("My Filter Processed...");
        chain.doFilter(request, response);
    }
}

@Bean
public FilterRegistrationBean<MyFilter> myFilter() {
  FilterRegistrationBean<MyFilter> filterFilterRegistrationBean = new FilterRegistrationBean<>();
  filterFilterRegistrationBean.setFilter(new MyFilter());
  filterFilterRegistrationBean.setUrlPatterns(Collections.singletonList("/servlet"));
  return filterFilterRegistrationBean;
}
```



#### Listener

可以使用 `ServletListenerRegistrationBean` 注册。

```java
public class MyListener implements ServletContextListener {
    private Log log = LogFactory.getLog(MyListener.class);
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        log.info("Servlet Context Inited");
    }
    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        log.info("Servlet Context Destroyed");
    }
}

@Bean
public ServletListenerRegistrationBean<MyListener> myListener() {
  return new ServletListenerRegistrationBean<>(new MyListener());
}
```

SpringBoot 在自动注册 Spring MVC 的时候会自动注册 `DispatcherServlet`。使用 `DispatcherServletAutoConfiguration` 进行注册。

```java
public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = "dispatcherServlet";

@Configuration(proxyBeanMethods = false)
@Conditional(DispatcherServletRegistrationCondition.class)
@ConditionalOnClass(ServletRegistration.class)
@EnableConfigurationProperties(WebMvcProperties.class)
@Import(DispatcherServletConfiguration.class)
protected static class DispatcherServletRegistrationConfiguration {

  @Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
  @ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
  public DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet,
                                                                         WebMvcProperties webMvcProperties, ObjectProvider<MultipartConfigElement> multipartConfig) {
    DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet,
                                                                                           webMvcProperties.getServlet().getPath());
    registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
    registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());
    multipartConfig.ifAvailable(registration::setMultipartConfig);
    return registration;
  }

}
```



### 切换嵌入式容器

在 Spring Boot 中除了支持 Tomcat 之外也支持 Jetty 和 Undertow 等另外两种 Servlet 容器。其中 Jetty 更适合于长链接的应用，而 Undertow 更适合于高并发的应用。

例如必须想要使用 Undertow 代替默认的 Tomcat 容器，首先在 pom 文件中去除 Tomcat 的依赖，然后加入 Undertow 的依赖即可。

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
  <exclusions>
    <exclusion>
      <artifactId>spring-boot-starter-tomcat</artifactId>
      <groupId>org.springframework.boot</groupId>
    </exclusion>
  </exclusions>
</dependency>

<dependency>
  <artifactId>spring-boot-starter-undertow</artifactId>
  <groupId>org.springframework.boot</groupId>
</dependency>
```

#### 嵌入式 Servlet 容器自动配置原理

SpringBoot 主要依赖于`ServletWebServerFactoryAutoConfiguration` 引入不同的嵌入式 Servlet。

其会引入各个 Servlet 容器的 Config 类，如下所示：

```java
@Configuration(proxyBeanMethods = false)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@ConditionalOnClass(ServletRequest.class)
@ConditionalOnWebApplication(type = Type.SERVLET)
@EnableConfigurationProperties(ServerProperties.class)
@Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,
		ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,
		ServletWebServerFactoryConfiguration.EmbeddedJetty.class,
		ServletWebServerFactoryConfiguration.EmbeddedUndertow.class })
public class ServletWebServerFactoryAutoConfiguration {
```

其中 Undertow 而配置如下：

```java
@Configuration(proxyBeanMethods = false)
class ServletWebServerFactoryConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })
	@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
	public static class EmbeddedUndertow {
		// 讲 Undertow 的 Factory 添加到容器中，通过其 getWebServer 方法即可获取到对应的 WebServer
		@Bean
		public UndertowServletWebServerFactory undertowServletWebServerFactory(
				ObjectProvider<UndertowDeploymentInfoCustomizer> deploymentInfoCustomizers,
				ObjectProvider<UndertowBuilderCustomizer> builderCustomizers) {
			UndertowServletWebServerFactory factory = new UndertowServletWebServerFactory();
			factory.getDeploymentInfoCustomizers()
					.addAll(deploymentInfoCustomizers.orderedStream().collect(Collectors.toList()));
			factory.getBuilderCustomizers().addAll(builderCustomizers.orderedStream().collect(Collectors.toList()));
			return factory;
		}

	}

}

```

同时其为容器导入了一个 `ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class` 后置处理器对容器进行处理。

```java
@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
                                    BeanDefinitionRegistry registry) {
  if (this.beanFactory == null) {
    return;
  }
  // 为容器导入了 WebServerFactoryCustomizerBeanPostProcessor 组件
  registerSyntheticBeanIfMissing(registry, "webServerFactoryCustomizerBeanPostProcessor",
                                 WebServerFactoryCustomizerBeanPostProcessor.class);
  registerSyntheticBeanIfMissing(registry, "errorPageRegistrarBeanPostProcessor",
                                 ErrorPageRegistrarBeanPostProcessor.class);
}
```

在 `WebServerFactoryCustomizerBeanPostProcessor` 中会调用 WebServer 容器的自定义配置。

```java
private void postProcessBeforeInitialization(WebServerFactory webServerFactory) {
  LambdaSafe.callbacks(WebServerFactoryCustomizer.class, getCustomizers(), webServerFactory)
    .withLogger(WebServerFactoryCustomizerBeanPostProcessor.class)
    .invoke((customizer) -> customizer.customize(webServerFactory));
}
```

SpringBoot 主要依赖 `EmbeddedWebServerFactoryCustomizerAutoConfiguration` 对嵌入式容器进行自动配置。

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication
@EnableConfigurationProperties(ServerProperties.class)
public class EmbeddedWebServerFactoryCustomizerAutoConfiguration {
  // 例如对于 Undertow 的配置
  @Configuration(proxyBeanMethods = false)
  // 在存在 Undertow 和 SslClientAuthMode 才会添加到容器中
	@ConditionalOnClass({ Undertow.class, SslClientAuthMode.class })
	public static class UndertowWebServerFactoryCustomizerConfiguration {
		@Bean
		public UndertowWebServerFactoryCustomizer undertowWebServerFactoryCustomizer(Environment environment,
				ServerProperties serverProperties) {
			return new UndertowWebServerFactoryCustomizer(environment, serverProperties);
		}
	}
}
```

可以看出在 autoConfig 中为容器中加入了一个 WebServerFactoryCustomizer，对 Servlet 容器的配置。SpringBoot 中默认有四个这样的 Customizer，其类结构图如下所示：

![WebServerFactoryCustomizer](http://img.sangzhenya.com/Snipaste_2019-12-17_23-22-31.png)

主要是从配置文件中读取相关的配置设置到 WebServer 上。

```java
public class UndertowWebServerFactoryCustomizer
		implements WebServerFactoryCustomizer<ConfigurableUndertowWebServerFactory>, Ordered {

	private final Environment environment;

	private final ServerProperties serverProperties;

	public UndertowWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) {
		this.environment = environment;
		this.serverProperties = serverProperties;
	}

	@Override
	public int getOrder() {
		return 0;
	}

	@Override
	public void customize(ConfigurableUndertowWebServerFactory factory) {
    // 从配置文件中配置并设置到容器上
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		FactoryOptions options = new FactoryOptions(factory);
		ServerProperties properties = this.serverProperties;
		map.from(properties::getMaxHttpHeaderSize).asInt(DataSize::toBytes).when(this::isPositive)
				.to(options.server(UndertowOptions.MAX_HEADER_SIZE));
		map.from(properties::getConnectionTimeout).asInt(Duration::toMillis)
				.to(options.server(UndertowOptions.NO_REQUEST_TIMEOUT));
		mapUndertowProperties(factory, options);
		mapAccessLogProperties(factory);
		map.from(this::getOrDeduceUseForwardHeaders).to(factory::setUseForwardHeaders);
	}
```



#### 嵌入式 Servlet 容器启动原理



