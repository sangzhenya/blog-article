## 异步线程池

在 Netty 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 Netty 对 Socket 的处理速度。解决方案则是将任务添加到异步线程池中，主要有两种方式：

1. handler 中加入线程池
2. context 中加入线程池

### Handler 中加入线程池

在 Handler 中添加一个 EventExecutorGroup，需要创建线程的时候使用 group.submit 创建线程，整个流程则变成如下：

![](http://img.programya.com/20200129085852.png)

当 IO 线程轮询到一个 Socket 事件，然后 IO 线程开始处理，当遇到耗时的 handler 的时候会将耗时的任务交给 业务线程池处理。当耗时的任务执行完毕再执行 pipeline write 方法的时候会将任务交给这个任务的 IO 线程。

看一下 AbstractChannelHandlerContext 的 write 方法

```java
private void write(Object msg, boolean flush, ChannelPromise promise) {
  ObjectUtil.checkNotNull(msg, "msg");
  try {
    if (isNotValidPromise(promise, true)) {
      ReferenceCountUtil.release(msg);
      // cancelled
      return;
    }
  } catch (RuntimeException e) {
    ReferenceCountUtil.release(msg);
    throw e;
  }

  final AbstractChannelHandlerContext next = findContextOutbound(flush ?
                                                                 (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);
  final Object m = pipeline.touch(msg, next);
  EventExecutor executor = next.executor();
  if (executor.inEventLoop()) {
    // 如果在当前线程则执行 write 或 writeAndFlush
    if (flush) {
      next.invokeWriteAndFlush(m, promise);
    } else {
      next.invokeWrite(m, promise);
    }
  } else {
    // 如果不在当前线程，则就当前任务封装成 task 然后放入 mpsc 队列中，
    // 等待 IO 任务执行完毕后执行队列中的任务
    final WriteTask task = WriteTask.newInstance(next, m, promise, flush);
    if (!safeExecute(executor, task, promise, m, !flush)) {
      // We failed to submit the WriteTask. We need to cancel it so we decrement the pending bytes
      // and put it back in the Recycler for re-use later.
      //
      // See https://github.com/netty/netty/issues/8343.
      task.cancel();
    }
  }
}
```



### Context 中加入线程池

