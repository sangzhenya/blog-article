## Java 逃逸分析

[TOC]

当一个对象在方法中被定义后，它可能被外部方法锁引用，例如作为调用参数传递到其他方法中，成为方法逃逸。甚至可能被外部线程访问到，例如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。逃逸分析的基本行为就是分析对象动态作用区域。

如果分析到一个对象不会逃逸到方法或者线程之外，则可以进行一些高效的优化，例如：

### 栈上分配

Java 虚拟机中，在 Java 堆上分配创建对象内存空间，其中的对象对于         各个线程都是共享可见的。只要持有了这个对象的引用，就可以访问堆中存储的对象数据。如果经过逃逸分析发现一个对象不会逃逸到方法之外，那么这个对象就可以在栈上分配内存，对象所占用的空间随着栈帧出栈而销毁。从而节约了垃圾收集器筛选和回收垃圾的时间。

### 同步消除

线程同步是一个相对耗时的过程，如果一个变量经过逃逸分析确定不会逃逸出线程，无法被其他线程访问，对这个变量实施的同步措施就可以消除掉，因为这个变量的读写不会有竞争。

### 标量替换

所谓的标量其实就是无法被分解成更小的数据来表示数据，例如 Java 中的原始数据类型，int, double 数值类型以及 reference 类型都是不能进一步拆解的，即是标量。如果一个数据可以拆解，就可以称为聚合量，Java 中的对象就是典型的聚合量。

如果经过逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那么程序执行的时候可能不会直接创建这个对象，而是直接创建它的若干个被这个方法使用到的成员变量进行替代。将对象拆分之后，可以让对象的成员变量在栈上分配和读写，还可以为后续的进一步优化创建条件。

逃逸分析是 JDK 1.6 才出现的，目前还尚未足够成熟，主要原因是不能保证逃逸分析的性能收益必定高于它的消耗。不过如果确实需要可以使用以下参数。

1.  `-XX:+DoEscapeAnalysis` 来手动开启逃逸分析。
2.  `-XX:+PrintEscapeAnalysis` 来查看分析结果。
3. `-XX:+EliminateAllocations` 有了逃逸分析的支持，开启标量替换。
4. `-XX:+EliminateLocks` 有了逃逸分析的支持，来开启同步消除。
5. `-XX:+PrintEliminateAllocations` 查看标量替换情况。