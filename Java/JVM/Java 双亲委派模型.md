---
title: "Java 双亲委派模型"
tags: ["Java", "JVM"]
categories: ["Java"]
date: "2020-02-07T09:00:00+08:00"
---

### 类加载机制

类从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括：加载 -> 验证 -> 准备 -> 解析 ->  初始化 ->  使用 ->  卸载  7个阶段。其中 验证、准备、解析三个阶段可以统称为连接。如图所示：

![Java 类加载过程](https://i.loli.net/2019/08/10/B6xZkNFj8hpIKgc.png)

以上过程中加载、验证、准备、初始化和卸载5个阶段的顺序是确定的，但是解析阶段则不一定，在一些情况下可以在初始化阶段之后再开始，主要是为了支持Java 的运行时绑定。Java 虚拟机对于什么时候开始类加载过程没有强制约束，但是严格规则了有且只有5中情况必须立刻对类进行初始化。

1. 遇到 `new`, `getstatic`, `putstatic` 或者 `invokestatic ` 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。对应的场景分别是 使用 new 关键字实例化对象，读取或者设置一个的类的静态字段（被 final 修饰、已经在编译期把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候。

2. 使用 `java.lang.reflect` 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

4. 当虚拟机启动时，用户需要制定一个要执行的主类，即包含 main 方法的那个类，虚拟机会先初始化这个类。

5. 当使用动态语言支持时，如果一个 `java.lang.invoke.MethodHandle` 实例最后解析的结果是 `REF_getStatic` 、`REF_putStatic`、`REF_invokeStatic` 的方法句柄，并且这个方法句柄对应的类没音进行过初始化，则需要先触发其初始化。

**类加载过程**

1. 加载

   在加载阶段虚拟机会完成以下 3 件事情：

   1. 通过一个类的全限定类名获取此类的二进制字节流。
   2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
   3. 在内存中生成一个代表这个类的 `java.lang.Class` 对象，作为方法区这个类各种数据访问入口。

   相对于类加载过程的其他阶段，一个非数组类的加载阶段是是开发人员可控性最强的，因为加载阶段可以使用系统的引导类加载器完成，也可以由用户自定义的类加载器去完成，开发人也可以通过自定义的类加载器去控制字节流的获取方式，即重写一个类加载器的 `loadClass()` 方法。

   加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义。然后在内存中实例化一个 `java.lang.Class` 类的对象，这个对象作为程序访问方法区中的这些类型数据的外部接口。

   加载阶段与连接阶段的部分内容，例如一部分字节码格式验证动作是交叉进行的。但是这两个阶段的开始时间仍然保持着固定的先后顺序。

2. 验证

   验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

   验证是非常重要的一个阶段，直接决定了 Java 虚拟机是否能承受恶意代码的攻击，从性能的角度上讲，验证阶段的工作量在虚拟机的类加载子系统中又占了相当大的一部分。整体上来讲验证阶段大致上会完成下面 4 个阶段的检验动作：

   1. 文件格式校验
   2. 元数据验证
   3. 字节码验证
   4. 符号引用验证

3. 准备

   准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的的内存都将在方法区进行分配。这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对鞋一起分配在 Java 堆中，另外这里说的初始值通常情况下是数据类型的零值。例如：`public static in value = 123`， 那变量 value 在准备阶段过后初始值为 0 而不是 123，因为把 value 值赋值为 123 的 `putstatic` 指令时被程编译后，存放在类构造器 `<clinit>()` 方法中，所以赋值为 123 的动作在初始化阶段才会执行。对于特殊的设置 final 的类变量在会在该阶段设置初始值。

4. 解析

   解析阶段是虚拟机将常量池内符号引用替换为直接引用的过程。符号引用以一组符号来描述所引用的目标。符号可以是任何形式的字面量，只要使用时无歧义的定位到目标即可。符号引用于虚拟机实现的内存布局无关，引用的目标不一定加载到内中。各种虚拟机实现内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确的在 Java 虚拟机规范的 Class 文件格式中。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，同一个符号引用在不同虚拟机实例上翻译处理的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。

5. 初始化

   类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全虚拟机主导和控制。到了初始化阶段，才开始真正的执行类中定义的 Java 程序代码。在准备阶段，变量已经被赋过一次值，而在初始化阶段，则根据程序员通过程序制定的规则去初始化变量和其他资源。也可以说是执行  `<clinit>()` 方法的过程。

### 什么是双亲委派模型

类加载器首先实现了类的加载，任意一个雷的都需要由它的加载器和这个类本身一同确立在 Java 虚拟机中的唯一性，每个加载器都拥有一个独立的类名称空间。

从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都是由 Java 语言实现，独立于虚拟机外部，并且全部都继承自抽象类 `java.lang.ClassLoader`。细分可以分为 3 种系统提供的类加载器。

1. 启动类加载器 (Bootstrap ClassLoader) ：这个类将负责将存放在 `<JAVA_HOME>\lib` 目录中，或者被 `-Xbootclasspath` 参数所指定的路径中，并且是虚拟机识别的类库加载到虚拟机内存中（例如 rt.jar, 名字不符合的类库即使存放在 lib 目录中也不会被加载）。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委托给引导类加载器，就直接使用 null 替换即可。
2. 扩展类加载器 (Extension ClassLoader) : 这个加载器由 `sun.misc.Launcher$ExtClassLoader` 实现，它负责加载 `<JAVA_HOME>\lib\ext` 目录中的，或者被 `java.ext.dirs` 系统变量所制定的路径中的所以类库，开发者可以直接使用扩展类加载器。
3. 应用程序加载器 (Application ClassLoader)：这个类加载器由 `sun.misc.Launcher$AppClassLoader` 实现。由于这个类加载器时 ClassLoader 中的 `getSystemClassLoader()` 方法的 返回值，所以一般也称它为系统类加载器。它负责加载用户路径 (ClassPath) 上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

应用程序中都是由这 3 个类加载器互相配合进行加载的，如果有必要，还可以假如自己定义的类加载器，这些类加载器之间的关系如下图所示：

![类加载器层次关系](https://i.loli.net/2019/08/10/LRYCztGENbDOjak.png)

类加载器之间的这种层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都是应当有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合的关系来复用父加载器的代码。类加载器的双亲委派模型不是一个强制性的约束模型，而是推荐的一种类加载器实现方式。

### 为什么使用以及如何实现双亲委派模型

使用双亲委派魔性来组织类加载器之间的关系， Java 类就随着它的类加载器一起具备了一种带有优先层次关系。例如类 `java.lang.Object` 它存放在 rt.jar 中，无论哪个类要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。如果没有使用双亲委派模型，各个类加载器自行去加载的话，如果用户编写了一个称为 `java.lang.Object` 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

### 破坏双亲委派模型

双亲委派很好的解决了各个类加载器的基础类统一的问题，基础类之所以称为 “基础”，是因为它们总是被用户代码调用的 API，但是在JNDI 服务中，基础类需要调用用户的代码，即独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者的代码。为了解决这个问题，Java 引入了线程上下文类加载器。这个类加载器可以通过 `java.lang.Thread` 类的 `setContextClassLoaser()` 方法进行设置，如果创建线程的时候还未设置，将会从父线程中继承一个，如果再应用程序的全局范围内都没有设置的话，那这个类加载器就是应用程序类加载器。有了这个类加载器，JNDI 服务使用这个线程上下文加载器去加载所需要的 SPI，即父加载器请求子类加载器去完成类加载的动作，实际上就是打通了双亲委派模型的层级结构来逆向使用类加载器。

此外为了实现程序的动态性，即热部署同样需要破坏双亲委派模型。OSGi 实现模块化热部署的关键在于它自定义了类加载器机制的实现。每一个程序模块都有一个自己的类加载器，需要更换一个模块的时，就把模块连同类加载器一起换掉以实现代码的热替换。

#### Tomcat 

Tomcat 作为一个 web 容器需要保证以下几点：

1. 同一个 Web 容器上两个 Web 应用程序使用到的 Java 类库可以实现互相隔离
2. 同一个 Web 容器上两个 Web 应用程序使用到的 Java 类库可以实现共享
3. Web 容器自身不被 Web 应用程序影响
4. 支持 jsp 修改，即支持热部署

Tomcat 类加载器设计如下：

![Tomcat 类加载器](https://i.loli.net/2019/08/11/zWaT5UO1kQJ6rtS.png)

Tomcat 下的类加载器：

1. `CommonClassLoader`： 加载  `/common/*` 下的类库，加载的 class 可以被 Tomcat 本身和各个 WebApp 访问。
2. `CatalinaClassLoader`： 加载  `/server/*` 下的类库，加载 class 对于 WebApp 不可见。
3. `SharedClassLoader`：  `/shared/*` 下的类库，加载的 class 对于所有 WebApp 可见，但是对于 Tomcat 容器不可见。
4.  `WebappClassLoader` ： 加载`/WebApp/WEB-INF/*` 下的类库，加载的 class 仅对于当前 WebApp 可见。
5. `JasperLoader`： 加载范围仅仅是单个 JSP 文件的所编译处理的一个 .class 文件。当 Web 容器检测到 JSP 文件被修改时，会替换目前的 JasperLoader 的实例。并通过再建立一个新的 JSP 类加载器实现 JSP 文件的 HotSwap 功能。



参考：

1. [深入理解Java虚拟机（第2版） : JVM高级特性与最佳实践](https://book.douban.com/subject/24722612/)
2. [深入理解 Tomcat（四）Tomcat 类加载器之为何违背双亲委派模型](https://www.jianshu.com/p/abf6fd4531e7)