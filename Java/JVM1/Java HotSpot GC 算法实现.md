---
title: "Java HotSpot GC 算法实现"
tags: ["Java", "JVM"]
categories: ["Java"]
date: "2020-03-01T09:00:00+08:00"
---

### 枚举根节点

可达性分析对执行时间的敏感体现在 GC 停顿上，因为分析工作必须在一个能确保一致性的快照中进行，即整个分析期间整个执行系统看起来就像冻结在某个时间点上，不能出现分析过程中对象引用关系还在不断变化的情况，否则分析结果的准确性就无法得到保证。这也是导致 GC 进行时必须停顿所有 Java 执行线程的一个重要原因，这点也被称为 “Stop The World”。

目前主流的 Java 虚拟机使用的是准确式 GC, 所以当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机是有办法得知哪些地方存着对象引用的。其中在 HotSpot 的实现中，是使用一组称为 OopMap 的数据结构来实现的，类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型数据计算出来，在 JIT 翻译过程中，也会在特性的位置记录下栈和寄存器中哪些位置是引用。如此一来，GC 在扫描时就可以直接得知这些信息了。

### 安全点

在 OopMap 的协助下，HotSpot 可以快速且准确的完成 GC Roots 枚举，但其实导致 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap 就需要大量额外的空间，增加 GC 的成本。所以实际上 HotSpot 只是在特定的位置记录了这些信息，这些位置称为 安全点。所以程序支持性并不是在所有地方都能够停下来开始 GC，而是只有在到达安全点时才能暂停。

如此一来 GC SafePoint 的选定其实也是一个问题，不能选定太少以致于 GC 等待的时间过长，但也不能太频繁以致于过分增大运行时的负荷。所以安全点的选定基本上是以具有让程序长时间运行的特征为标准进行选定的，因为每条指令执行的时间都非常短暂，所以程序不太可能因为指令流长度太长这个原因而导致长时间运行。那么长时间执行的最明显特征就是执行序列复用，例如方法调用、循环跳转、异常跳转等，具备这些功能的指令才会产生 SafePoint。

那么随之而来的问题时如何在 GC 的时候让所有线程都跑到最近的安全点再停顿下来。有两种方案，意思是抢先式中断，一种是主动式中断。目前虚拟机几乎都是使用主动式中断，主要思想是不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时主动区轮询这个标志，发现中断标志为真的时候就自己中断挂起，轮询标志的地方和安全点时重合的，另外再加上对象需要分配内存的地方。

### 安全区域

虽然安全点机制保证了程序执行时再不太长的时间内就会遇到可进入 GC 的 SafePoint。但是对于程序不执行的情况，例如线程时 Sleep 状态或者 Bloked 状态，就无法响应 JVM 的中断请求，同时 JVM 也不会等到线程重新分配 CPU 时间，所以就需要安全区域来解决。所谓的安全区域表示一段代码片段之中，引用关系不会发生变化，再这个区域中任意地方开始 GC 都是 安全的，可以把  Safe Region 看作是被扩展了的 SafePoint。

再线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region，如此这段时间里 JVM要发起 GC 时，就不管自己表示为 Safe Region状态的线程了。在线程离开 Safe Region 时，需要检查系统是否完成了根节点的枚举，如果完成线程就继续执行，否则就必须等待知道收到可以安全离开 Safe Region 的信号为止。



参考：[深入理解Java虚拟机（第2版） : JVM高级特性与最佳实践](https://book.douban.com/subject/24722612/)